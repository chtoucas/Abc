Abc.Extensions.DictionaryX
Abc.Extensions.NameValueCollectionX
Abc.Linq.Qperators
Abc.Maybe
Abc.Maybe<T>
Abc.Maybe<T>.Apply<TResult>(Abc.Maybe<System.Func<T, TResult>> applicative) -> Abc.Maybe<TResult>
Abc.Maybe<T>.Bind<TResult>(System.Func<T, Abc.Maybe<TResult>> binder) -> Abc.Maybe<TResult>
Abc.Maybe<T>.BindAsync<TResult>(System.Func<T, System.Threading.Tasks.Task<Abc.Maybe<TResult>>> binder) -> System.Threading.Tasks.Task<Abc.Maybe<TResult>>
Abc.Maybe<T>.CompareTo(Abc.Maybe<T> other) -> int
Abc.Maybe<T>.Contains(T value) -> bool
Abc.Maybe<T>.ContinueWith<TResult>(Abc.Maybe<TResult> other) -> Abc.Maybe<TResult>
Abc.Maybe<T>.Do(System.Action<T> onSome, System.Action onNone) -> void
Abc.Maybe<T>.Duplicate() -> Abc.Maybe<Abc.Maybe<T>>
Abc.Maybe<T>.Equals(Abc.Maybe<T> other) -> bool
Abc.Maybe<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Abc.Maybe<T>.IsNone.get -> bool
Abc.Maybe<T>.Join<TInner, TKey, TResult>(Abc.Maybe<TInner> inner, System.Func<T, TKey> outerKeySelector, System.Func<TInner, TKey> innerKeySelector, System.Func<T, TInner, TResult> resultSelector) -> Abc.Maybe<TResult>
Abc.Maybe<T>.Join<TInner, TKey, TResult>(Abc.Maybe<TInner> inner, System.Func<T, TKey> outerKeySelector, System.Func<TInner, TKey> innerKeySelector, System.Func<T, TInner, TResult> resultSelector, System.Collections.Generic.IEqualityComparer<TKey> comparer) -> Abc.Maybe<TResult>
Abc.Maybe<T>.OnSome(System.Action<T> action) -> void
Abc.Maybe<T>.OrElse(Abc.Maybe<T> other) -> Abc.Maybe<T>
Abc.Maybe<T>.OrElseAsync(System.Threading.Tasks.Task<Abc.Maybe<T>> other) -> System.Threading.Tasks.Task<Abc.Maybe<T>>
Abc.Maybe<T>.PassThru<TOther>(Abc.Maybe<TOther> other) -> Abc.Maybe<T>
Abc.Maybe<T>.ReplaceWith<TResult>(TResult value) -> Abc.Maybe<TResult>
Abc.Maybe<T>.Replicate() -> Abc.Maybe<System.Collections.Generic.IEnumerable<T>>
Abc.Maybe<T>.Replicate(int count) -> Abc.Maybe<System.Collections.Generic.IEnumerable<T>>
Abc.Maybe<T>.Select<TResult>(System.Func<T, TResult> selector) -> Abc.Maybe<TResult>
Abc.Maybe<T>.SelectAsync<TResult>(System.Func<T, System.Threading.Tasks.Task<TResult>> selector) -> System.Threading.Tasks.Task<Abc.Maybe<TResult>>
Abc.Maybe<T>.SelectMany<TMiddle, TResult>(System.Func<T, Abc.Maybe<TMiddle>> selector, System.Func<T, TMiddle, TResult> resultSelector) -> Abc.Maybe<TResult>
Abc.Maybe<T>.Skip() -> Abc.Maybe<Abc.Unit>
Abc.Maybe<T>.Switch<TResult>(System.Func<T, TResult> caseSome, System.Func<TResult> caseNone) -> TResult
Abc.Maybe<T>.Switch<TResult>(System.Func<T, TResult> caseSome, TResult caseNone) -> TResult
Abc.Maybe<T>.SwitchAsync<TResult>(System.Func<T, System.Threading.Tasks.Task<TResult>> caseSome, System.Threading.Tasks.Task<TResult> caseNone) -> System.Threading.Tasks.Task<TResult>
Abc.Maybe<T>.ValueOrDefault() -> T
Abc.Maybe<T>.ValueOrElse(System.Func<T> valueFactory) -> T
Abc.Maybe<T>.ValueOrElse(T other) -> T
Abc.Maybe<T>.ValueOrThrow() -> T
Abc.Maybe<T>.ValueOrThrow(System.Func<System.Exception> exceptionFactory) -> T
Abc.Maybe<T>.Where(System.Func<T, bool> predicate) -> Abc.Maybe<T>
Abc.Maybe<T>.XorElse(Abc.Maybe<T> other) -> Abc.Maybe<T>
Abc.Maybe<T>.Yield() -> System.Collections.Generic.IEnumerable<T>
Abc.Maybe<T>.Yield(int count) -> System.Collections.Generic.IEnumerable<T>
Abc.Maybe<T>.ZipWith<TOther, TResult>(Abc.Maybe<TOther> other, System.Func<T, TOther, TResult> zipper) -> Abc.Maybe<TResult>
Abc.Unit
Abc.Unit.Equals(Abc.Unit other) -> bool
Abc.Unit.Equals(System.ValueTuple other) -> bool
Abc.Unit.Unit() -> void
override Abc.Maybe<T>.Equals(object obj) -> bool
override Abc.Maybe<T>.GetHashCode() -> int
override Abc.Maybe<T>.ToString() -> string
override Abc.Unit.Equals(object obj) -> bool
override Abc.Unit.GetHashCode() -> int
override Abc.Unit.ToString() -> string
static Abc.Extensions.DictionaryX.MayGetValue<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> this, TKey key) -> Abc.Maybe<TValue>
static Abc.Extensions.NameValueCollectionX.MayGetSingle(this System.Collections.Specialized.NameValueCollection this, string name) -> Abc.Maybe<string>
static Abc.Extensions.NameValueCollectionX.MayGetValues(this System.Collections.Specialized.NameValueCollection this, string name) -> Abc.Maybe<string[]>
static Abc.Extensions.NameValueCollectionX.ParseValues<T>(this System.Collections.Specialized.NameValueCollection this, string name, System.Func<string, Abc.Maybe<T>> parser) -> System.Collections.Generic.IEnumerable<T>
static Abc.Linq.Qperators.ElementAtOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, int index) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.FirstOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.FirstOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, bool> predicate) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.LastOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.LastOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, bool> predicate) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.MayFold<TSource, TAccumulate>(this System.Collections.Generic.IEnumerable<TSource> source, TAccumulate seed, System.Func<TAccumulate, TSource, Abc.Maybe<TAccumulate>> accumulator) -> Abc.Maybe<TAccumulate>
static Abc.Linq.Qperators.MayFold<TSource, TAccumulate>(this System.Collections.Generic.IEnumerable<TSource> source, TAccumulate seed, System.Func<TAccumulate, TSource, Abc.Maybe<TAccumulate>> accumulator, System.Func<Abc.Maybe<TAccumulate>, bool> predicate) -> Abc.Maybe<TAccumulate>
static Abc.Linq.Qperators.MayReduce<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TSource, Abc.Maybe<TSource>> accumulator) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.MayReduce<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TSource, Abc.Maybe<TSource>> accumulator, System.Func<Abc.Maybe<TSource>, bool> predicate) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.SelectAny<TSource, TResult>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, Abc.Maybe<TResult>> selector) -> System.Collections.Generic.IEnumerable<TResult>
static Abc.Linq.Qperators.SingleOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.SingleOrNone<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, bool> predicate) -> Abc.Maybe<TSource>
static Abc.Linq.Qperators.WhereAny<TSource>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, Abc.Maybe<bool>> predicate) -> System.Collections.Generic.IEnumerable<TSource>
static Abc.Linq.Qperators.ZipAny<T1, T2, TResult>(this System.Collections.Generic.IEnumerable<T1> first, System.Collections.Generic.IEnumerable<T2> second, System.Func<T1, T2, Abc.Maybe<TResult>> resultSelector) -> System.Collections.Generic.IEnumerable<TResult>
static Abc.Maybe.Any<T>(System.Collections.Generic.IEnumerable<Abc.Maybe<T>> source) -> Abc.Maybe<T>
static Abc.Maybe.CollectAny<T>(System.Collections.Generic.IEnumerable<Abc.Maybe<T>> source) -> System.Collections.Generic.IEnumerable<T>
static Abc.Maybe.Compose<TSource, TMiddle, TResult>(this System.Func<TSource, Abc.Maybe<TMiddle>> this, System.Func<TMiddle, Abc.Maybe<TResult>> other) -> System.Func<TSource, Abc.Maybe<TResult>>
static Abc.Maybe.ComposeBack<TSource, TMiddle, TResult>(this System.Func<TMiddle, Abc.Maybe<TResult>> this, System.Func<TSource, Abc.Maybe<TMiddle>> other) -> System.Func<TSource, Abc.Maybe<TResult>>
static Abc.Maybe.Empty<T>() -> Abc.Maybe<System.Collections.Generic.IEnumerable<T>>
static Abc.Maybe.Flatten<T>(this in Abc.Maybe<Abc.Maybe<T>> this) -> Abc.Maybe<T>
static Abc.Maybe.Guard(bool predicate) -> Abc.Maybe<Abc.Unit>
static Abc.Maybe.Invoke<T1, T2, T3, T4, T5, TResult>(this Abc.Maybe<System.Func<T1, T2, T3, T4, T5, TResult>> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third, Abc.Maybe<T4> fourth, Abc.Maybe<T5> fifth) -> Abc.Maybe<TResult>
static Abc.Maybe.Invoke<T1, T2, T3, T4, TResult>(this Abc.Maybe<System.Func<T1, T2, T3, T4, TResult>> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third, Abc.Maybe<T4> fourth) -> Abc.Maybe<TResult>
static Abc.Maybe.Invoke<T1, T2, T3, TResult>(this Abc.Maybe<System.Func<T1, T2, T3, TResult>> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third) -> Abc.Maybe<TResult>
static Abc.Maybe.Invoke<T1, T2, TResult>(this Abc.Maybe<System.Func<T1, T2, TResult>> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second) -> Abc.Maybe<TResult>
static Abc.Maybe.Invoke<TSource, TResult>(this Abc.Maybe<System.Func<TSource, TResult>> this, Abc.Maybe<TSource> maybe) -> Abc.Maybe<TResult>
static Abc.Maybe.Invoke<TSource, TResult>(this System.Func<TSource, Abc.Maybe<TResult>> this, Abc.Maybe<TSource> maybe) -> Abc.Maybe<TResult>
static Abc.Maybe.Lift<T1, T2, T3, T4, T5, TResult>(this System.Func<T1, T2, T3, T4, T5, TResult> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third, Abc.Maybe<T4> fourth, Abc.Maybe<T5> fifth) -> Abc.Maybe<TResult>
static Abc.Maybe.Lift<T1, T2, T3, T4, TResult>(this System.Func<T1, T2, T3, T4, TResult> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third, Abc.Maybe<T4> fourth) -> Abc.Maybe<TResult>
static Abc.Maybe.Lift<T1, T2, T3, TResult>(this System.Func<T1, T2, T3, TResult> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second, Abc.Maybe<T3> third) -> Abc.Maybe<TResult>
static Abc.Maybe.Lift<T1, T2, TResult>(this System.Func<T1, T2, TResult> this, Abc.Maybe<T1> first, Abc.Maybe<T2> second) -> Abc.Maybe<TResult>
static Abc.Maybe.Lift<TSource, TResult>(this System.Func<TSource, TResult> this, Abc.Maybe<TSource> maybe) -> Abc.Maybe<TResult>
static Abc.Maybe.Of<T>(T value) -> Abc.Maybe<T>
static Abc.Maybe.Of<T>(T? value) -> Abc.Maybe<T>
static Abc.Maybe.Some<T>(T value) -> Abc.Maybe<T>
static Abc.Maybe.Squash<T>(this in Abc.Maybe<T?> this) -> Abc.Maybe<T>
static Abc.Maybe.ToNullable<T>(this in Abc.Maybe<T> this) -> T?
static Abc.Maybe.ToNullable<T>(this in Abc.Maybe<T?> this) -> T?
static Abc.Maybe.Use<TDisposable, TResult>(this Abc.Maybe<TDisposable> this, System.Func<TDisposable, Abc.Maybe<TResult>> binder) -> Abc.Maybe<TResult>
static Abc.Maybe.Use<TDisposable, TResult>(this Abc.Maybe<TDisposable> this, System.Func<TDisposable, TResult> selector) -> Abc.Maybe<TResult>
static Abc.Maybe.ValueOrEmpty<T>(this Abc.Maybe<System.Collections.Generic.IEnumerable<T>> this) -> System.Collections.Generic.IEnumerable<T>
static Abc.Maybe<T>.None.get -> Abc.Maybe<T>
static Abc.Maybe<T>.explicit operator Abc.Maybe<T>(Abc.Maybe<Abc.Maybe<T>> maybe) -> Abc.Maybe<T>
static Abc.Maybe<T>.operator !=(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Maybe<T>.operator <(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Maybe<T>.operator <=(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Maybe<T>.operator ==(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Maybe<T>.operator >(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Maybe<T>.operator >=(Abc.Maybe<T> left, Abc.Maybe<T> right) -> bool
static Abc.Unit.operator !=(Abc.Unit left, Abc.Unit right) -> bool
static Abc.Unit.operator !=(Abc.Unit left, System.ValueTuple right) -> bool
static Abc.Unit.operator !=(System.ValueTuple left, Abc.Unit right) -> bool
static Abc.Unit.operator ==(Abc.Unit left, Abc.Unit right) -> bool
static Abc.Unit.operator ==(Abc.Unit left, System.ValueTuple right) -> bool
static Abc.Unit.operator ==(System.ValueTuple left, Abc.Unit right) -> bool
static readonly Abc.Maybe.Unit -> Abc.Maybe<Abc.Unit>
static readonly Abc.Maybe.Zero -> Abc.Maybe<Abc.Unit>
static readonly Abc.Unit.Default -> Abc.Unit
